#!/bin/bash

# Test helper functions for lunacopy.sh testing

# Create a temporary directory for tests
setup_test_env() {
    export TEST_DIR=$(mktemp -d)
    export LUNACOPY_SCRIPT="$(pwd)/lunacopy.sh"
    cd "$TEST_DIR"
}

# Clean up test environment
cleanup_test_env() {
    if [[ -n "$TEST_DIR" && -d "$TEST_DIR" ]]; then
        rm -rf "$TEST_DIR"
    fi
}

# Create a test file with specific content
create_test_file() {
    local filename="$1"
    local content="$2"
    local dir="$(dirname "$filename")"
    
    if [[ "$dir" != "." ]]; then
        mkdir -p "$dir"
    fi
    
    echo "$content" > "$filename"
}

# Create a test directory structure
create_test_directory() {
    local dirname="$1"
    mkdir -p "$dirname"
    
    # Create some test files
    create_test_file "$dirname/file1.txt" "This is test file 1"
    create_test_file "$dirname/file2.txt" "This is test file 2"
    create_test_file "$dirname/subdir/file3.txt" "This is test file 3 in subdir"
}

# Run lunacopy with automated input
run_lunacopy_with_input() {
    local input="$1"
    shift
    # Create a temporary file with the input
    local input_file=$(mktemp)
    printf "%s\n" "$input" > "$input_file"
    "$LUNACOPY_SCRIPT" "$@" < "$input_file"
    local exit_code=$?
    rm -f "$input_file"
    return $exit_code
}

# Check if a file exists and is not empty
file_exists_and_not_empty() {
    [[ -f "$1" && -s "$1" ]]
}

# Count lines in a file
count_lines() {
    wc -l < "$1"
}

# Create a legacy format hash file for testing import
create_legacy_md5() {
    local filename="$1"
    cat > "$filename" << 'EOF'
; Generated by SomethingCopy
;
; MD5 checksums generated at 2023-08-18 12:00:00
d41d8cd98f00b204e9800998ecf8427e *file1.txt
5d41402abc4b2a76b9719d911017c592 *file2.txt
098f6bcd4621d373cade4e832627b4f6 *subdir\file3.txt
EOF
}

# Create a legacy format sha256 file for testing import
create_legacy_sha256() {
    local filename="$1"
    cat > "$filename" << 'EOF'
; Generated by SomethingCopy
;
; SHA256 checksums generated at 2023-08-18 12:00:00
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 *file1.txt
ef2d127de37b942baad06145e54b0c619a1f22327b2ebbcfbec78f5564afe39d *file2.txt
a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3 *subdir\file3.txt
EOF
}

# Verify hash file format
verify_lunacopy_format() {
    local hashfile="$1"
    
    # Check if all lines follow the format: hash  filename
    while IFS= read -r line; do
        if [[ ! "$line" =~ ^[a-f0-9]+[[:space:]]{2}[^[:space:]]+ ]]; then
            echo "Invalid format in line: $line"
            return 1
        fi
    done < "$hashfile"
    return 0
}

# Mock user input for interactive prompts
mock_input() {
    local responses="$1"
    export MOCK_RESPONSES="$responses"
}

# Override read command for testing
read() {
    if [[ -n "$MOCK_RESPONSES" ]]; then
        local response
        response=$(echo "$MOCK_RESPONSES" | cut -d'|' -f1)
        MOCK_RESPONSES=$(echo "$MOCK_RESPONSES" | cut -d'|' -f2-)
        echo "$response"
        return 0
    else
        command read "$@"
    fi
}
